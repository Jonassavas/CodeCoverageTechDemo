


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > MinimalEncoder</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.google.zxing.datamatrix.encoder</a>
</div>

<h1>Coverage Summary for Class: MinimalEncoder (com.google.zxing.datamatrix.encoder)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MinimalEncoder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.7%
  </span>
  <span class="absValue">
    (87/90)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MinimalEncoder$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MinimalEncoder$Edge</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (22/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.6%
  </span>
  <span class="absValue">
    (218/238)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MinimalEncoder$Input</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MinimalEncoder$Mode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MinimalEncoder$Result</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.4%
  </span>
  <span class="absValue">
    (54/56)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (48/48)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.7%
  </span>
  <span class="absValue">
    (374/399)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2021 ZXing authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package com.google.zxing.datamatrix.encoder;
&nbsp;
&nbsp;import java.nio.charset.Charset;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import com.google.zxing.common.MinimalECIInput;
&nbsp;
&nbsp;/**
&nbsp; * Encoder that encodes minimally
&nbsp; *
&nbsp; * Algorithm:
&nbsp; *
&nbsp; * Uses Dijkstra to produce mathematically minimal encodings that are in some cases smaller than the results produced
&nbsp; * by the algorithm described in annex S in the specification ISO/IEC 16022:200(E). The biggest improvment of this
&nbsp; * algorithm over that one is the case when the algorithm enters the most inefficient mode, the B256 mode. The
&nbsp; * algorithm from the specification algorithm will exit this mode only if it encounters digits so that arbitrarily
&nbsp; * inefficient results can be produced if the postfix contains no digits.
&nbsp; *
&nbsp; * Multi ECI support and ECI switching:
&nbsp; *
&nbsp; * For multi language content the algorithm selects the most compact representation using ECI modes. Note that unlike
&nbsp; * the compaction algorithm used for QR-Codes, this implementation operates in two stages and therfore is not
&nbsp; * mathematically optimal. In the first stage, the input string is encoded minimally as a stream of ECI character set
&nbsp; * selectors and bytes encoded in the selected encoding. In this stage the algorithm might for example decide to
&nbsp; * encode ocurrences of the characters &quot;\u0150\u015C&quot; (O-double-acute, S-circumflex) in UTF-8 by a single ECI or
&nbsp; * alternatively by multiple ECIs that switch between IS0-8859-2 and ISO-8859-3 (e.g. in the case that the input
&nbsp; * contains many * characters from ISO-8859-2 (Latin 2) and few from ISO-8859-3 (Latin 3)).
&nbsp; * In a second stage this stream of ECIs and bytes is minimally encoded using the various Data Matrix encoding modes.
&nbsp; * While both stages encode mathematically minimally it is not ensured that the result is mathematically minimal since
&nbsp; * the size growth for inserting an ECI in the first stage can only be approximated as the first stage does not know
&nbsp; * in which mode the ECI will occur in the second stage (may, or may not require an extra latch to ASCII depending on
&nbsp; * the current mode). The reason for this shortcoming are difficulties in implementing it in a straightforward and
&nbsp; * readable manner.
&nbsp; *
&nbsp; * GS1 support
&nbsp; *
&nbsp; * FNC1 delimiters can be encoded in the input string by using the FNC1 character specified in the encoding function.
&nbsp; * When a FNC1 character is specified then a leading FNC1 will be encoded and all ocurrences of delimiter characters
&nbsp; * while result in FNC1 codewords in the symbol.
&nbsp; *
&nbsp; * @author Alex Geller
&nbsp; */
<b class="fc">&nbsp;public final class MinimalEncoder {</b>
&nbsp;
<b class="fc">&nbsp;  enum Mode {</b>
<b class="fc">&nbsp;    ASCII,</b>
<b class="fc">&nbsp;    C40,</b>
<b class="fc">&nbsp;    TEXT,</b>
<b class="fc">&nbsp;    X12,</b>
<b class="fc">&nbsp;    EDF,</b>
<b class="fc">&nbsp;    B256</b>
&nbsp;  }
<b class="fc">&nbsp;  static final char[] C40_SHIFT2_CHARS = {&#39;!&#39;, &#39;&quot;&#39;, &#39;#&#39;, &#39;$&#39;, &#39;%&#39;, &#39;&amp;&#39;, &#39;\&#39;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;*&#39;,  &#39;+&#39;, &#39;,&#39;, &#39;-&#39;, &#39;.&#39;, &#39;/&#39;,</b>
&nbsp;                                          &#39;:&#39;, &#39;;&#39;, &#39;&lt;&#39;, &#39;=&#39;, &#39;&gt;&#39;, &#39;?&#39;,  &#39;@&#39;, &#39;[&#39;, &#39;\\&#39;, &#39;]&#39;, &#39;^&#39;, &#39;_&#39; };
&nbsp;
&nbsp;
&nbsp;  private MinimalEncoder() {
&nbsp;  }
&nbsp;
&nbsp;  static boolean isExtendedASCII(char ch, int fnc1) {
<b class="fc">&nbsp;    return ch != fnc1 &amp;&amp; ch &gt;= 128 &amp;&amp; ch &lt;= 255;</b>
&nbsp;  }
&nbsp;
&nbsp;  private static boolean isInC40Shift1Set(char ch) {
<b class="fc">&nbsp;    return ch &lt;= 31;</b>
&nbsp;  }
&nbsp;
&nbsp;  private static boolean isInC40Shift2Set(char ch, int fnc1) {
<b class="fc">&nbsp;    for (char c40Shift2Char : C40_SHIFT2_CHARS) {</b>
<b class="fc">&nbsp;      if (c40Shift2Char == ch) {</b>
<b class="fc">&nbsp;        return true;</b>
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    return ch == fnc1;</b>
&nbsp;  }
&nbsp;
&nbsp;  private static boolean isInTextShift1Set(char ch) {
<b class="fc">&nbsp;    return isInC40Shift1Set(ch);</b>
&nbsp;  }
&nbsp;
&nbsp;  private static boolean isInTextShift2Set(char ch, int fnc1) {
<b class="fc">&nbsp;    return isInC40Shift2Set(ch, fnc1);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Performs message encoding of a DataMatrix message
&nbsp;   *
&nbsp;   * @param msg the message
&nbsp;   * @return the encoded message (the char values range from 0 to 255)
&nbsp;   */
&nbsp;  public static String encodeHighLevel(String msg) {
<b class="fc">&nbsp;    return encodeHighLevel(msg, null, -1, SymbolShapeHint.FORCE_NONE);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Performs message encoding of a DataMatrix message
&nbsp;   *
&nbsp;   * @param msg the message
&nbsp;   * @param priorityCharset The preferred {@link Charset}. When the value of the argument is null, the algorithm
&nbsp;   *   chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority
&nbsp;   *   charset to encode any character in the input that can be encoded by it if the charset is among the
&nbsp;   *   supported charsets.
&nbsp;   * @param fnc1 denotes the character in the input that represents the FNC1 character or -1 if this is not a GS1
&nbsp;   *   bar code. If the value is not -1 then a FNC1 is also prepended.
&nbsp;   * @param shape requested shape.
&nbsp;   * @return the encoded message (the char values range from 0 to 255)
&nbsp;   */
&nbsp;  public static String encodeHighLevel(String msg, Charset priorityCharset, int fnc1, SymbolShapeHint shape) {
<b class="fc">&nbsp;    int macroId = 0;</b>
<b class="fc">&nbsp;    if (msg.startsWith(HighLevelEncoder.MACRO_05_HEADER) &amp;&amp; msg.endsWith(HighLevelEncoder.MACRO_TRAILER)) {</b>
<b class="fc">&nbsp;      macroId = 5;</b>
<b class="fc">&nbsp;      msg = msg.substring(HighLevelEncoder.MACRO_05_HEADER.length(), msg.length() - 2);</b>
<b class="fc">&nbsp;    } else if (msg.startsWith(HighLevelEncoder.MACRO_06_HEADER) &amp;&amp; msg.endsWith(HighLevelEncoder.MACRO_TRAILER)) {</b>
<b class="nc">&nbsp;      macroId = 6;</b>
<b class="nc">&nbsp;      msg = msg.substring(HighLevelEncoder.MACRO_06_HEADER.length(), msg.length() - 2);</b>
&nbsp;    }
<b class="fc">&nbsp;    return new String(encode(msg, priorityCharset, fnc1, shape, macroId), StandardCharsets.ISO_8859_1);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Encodes input minimally and returns an array of the codewords
&nbsp;   *
&nbsp;   * @param input The string to encode
&nbsp;   * @param priorityCharset The preferred {@link Charset}. When the value of the argument is null, the algorithm
&nbsp;   *   chooses charsets that leads to a minimal representation. Otherwise the algorithm will use the priority
&nbsp;   *   charset to encode any character in the input that can be encoded by it if the charset is among the
&nbsp;   *   supported charsets.
&nbsp;   * @param fnc1 denotes the character in the input that represents the FNC1 character or -1 if this is not a GS1
&nbsp;   *   bar code. If the value is not -1 then a FNC1 is also prepended.
&nbsp;   * @param shape requested shape.
&nbsp;   * @param macroId Prepends the specified macro function in case that a value of 5 or 6 is specified.
&nbsp;   * @return An array of bytes representing the codewords of a minimal encoding.
&nbsp;   */
&nbsp;  static byte[] encode(String input, Charset priorityCharset, int fnc1, SymbolShapeHint shape, int macroId) {
<b class="fc">&nbsp;    return encodeMinimally(new Input(input, priorityCharset, fnc1, shape, macroId)).getBytes();</b>
&nbsp;  }
&nbsp;
&nbsp;  static void addEdge(Edge[][] edges, Edge edge) {
<b class="fc">&nbsp;    int vertexIndex = edge.fromPosition + edge.characterLength;</b>
<b class="fc">&nbsp;    if (edges[vertexIndex][edge.getEndMode().ordinal()] == null ||</b>
<b class="fc">&nbsp;        edges[vertexIndex][edge.getEndMode().ordinal()].cachedTotalSize &gt; edge.cachedTotalSize) {</b>
<b class="fc">&nbsp;      edges[vertexIndex][edge.getEndMode().ordinal()] = edge;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /** @return the number of words in which the string starting at from can be encoded in c40 or text mode.
&nbsp;   *  The number of characters encoded is returned in characterLength.
&nbsp;   *  The number of characters encoded is also minimal in the sense that the algorithm stops as soon
&nbsp;   *  as a character encoding fills a C40 word competely (three C40 values). An exception is at the
&nbsp;   *  end of the string where two C40 values are allowed (according to the spec the third c40 value
&nbsp;   *  is filled  with 0 (Shift 1) in this case).
&nbsp;   */
&nbsp;  static int getNumberOfC40Words(Input input, int from, boolean c40,int[] characterLength) {
<b class="fc">&nbsp;    int thirdsCount = 0;</b>
<b class="fc">&nbsp;    for (int i = from; i &lt; input.length(); i++) {</b>
<b class="fc">&nbsp;      if (input.isECI(i)) {</b>
<b class="fc">&nbsp;        characterLength[0] = 0;</b>
<b class="fc">&nbsp;        return 0;</b>
&nbsp;      }
<b class="fc">&nbsp;      char ci = input.charAt(i);</b>
<b class="fc">&nbsp;      if (c40 &amp;&amp; HighLevelEncoder.isNativeC40(ci) || !c40 &amp;&amp; HighLevelEncoder.isNativeText(ci)) {</b>
<b class="fc">&nbsp;        thirdsCount++; //native</b>
<b class="fc">&nbsp;      } else if (!isExtendedASCII(ci, input.getFNC1Character())) {</b>
<b class="fc">&nbsp;        thirdsCount += 2; //shift</b>
&nbsp;      } else {
<b class="fc">&nbsp;        int asciiValue = ci &amp; 0xff;</b>
<b class="fc">&nbsp;        if (asciiValue &gt;= 128 &amp;&amp; (c40 &amp;&amp; HighLevelEncoder.isNativeC40((char) (asciiValue - 128)) ||</b>
<b class="fc">&nbsp;                                  !c40 &amp;&amp; HighLevelEncoder.isNativeText((char) (asciiValue - 128)))) {</b>
<b class="fc">&nbsp;          thirdsCount += 3; // shift, Upper shift</b>
&nbsp;        } else {
<b class="fc">&nbsp;          thirdsCount += 4; // shift, Upper shift, shift</b>
&nbsp;        }
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      if (thirdsCount % 3 == 0 || ((thirdsCount - 2) % 3 == 0 &amp;&amp; i + 1 == input.length())) {</b>
<b class="fc">&nbsp;        characterLength[0] = i - from + 1;</b>
<b class="fc">&nbsp;        return (int) Math.ceil(((double) thirdsCount) / 3.0);</b>
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    characterLength[0] = 0;</b>
<b class="fc">&nbsp;    return 0;</b>
&nbsp;  }
&nbsp;
&nbsp;  static void addEdges(Input input, Edge[][] edges, int from, Edge previous) {
&nbsp;
<b class="fc">&nbsp;    if (input.isECI(from)) {</b>
<b class="fc">&nbsp;      addEdge(edges, new Edge(input, Mode.ASCII, from, 1, previous));</b>
&nbsp;      return;
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    char ch = input.charAt(from);</b>
<b class="fc">&nbsp;    if (previous == null || previous.getEndMode() != Mode.EDF) { //not possible to unlatch a full EDF edge to something</b>
&nbsp;                                                                 //else
<b class="fc">&nbsp;      if (HighLevelEncoder.isDigit(ch) &amp;&amp; input.haveNCharacters(from, 2) &amp;&amp;</b>
<b class="fc">&nbsp;          HighLevelEncoder.isDigit(input.charAt(from + 1))) {</b>
&nbsp;        // two digits ASCII encoded
<b class="fc">&nbsp;        addEdge(edges, new Edge(input, Mode.ASCII, from, 2, previous));</b>
&nbsp;      } else {
&nbsp;        // one ASCII encoded character or an extended character via Upper Shift
<b class="fc">&nbsp;        addEdge(edges, new Edge(input, Mode.ASCII, from, 1, previous));</b>
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      Mode[] modes = {Mode.C40, Mode.TEXT};</b>
<b class="fc">&nbsp;      for (Mode mode : modes) {</b>
<b class="fc">&nbsp;        int[] characterLength = new int[1];</b>
<b class="fc">&nbsp;        if (getNumberOfC40Words(input, from, mode == Mode.C40, characterLength) &gt; 0) {</b>
<b class="fc">&nbsp;          addEdge(edges, new Edge(input, mode, from, characterLength[0], previous));</b>
&nbsp;        }
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      if (input.haveNCharacters(from,3) &amp;&amp;</b>
<b class="fc">&nbsp;          HighLevelEncoder.isNativeX12(input.charAt(from)) &amp;&amp;</b>
<b class="fc">&nbsp;          HighLevelEncoder.isNativeX12(input.charAt(from + 1)) &amp;&amp;</b>
<b class="fc">&nbsp;          HighLevelEncoder.isNativeX12(input.charAt(from + 2))) {</b>
<b class="fc">&nbsp;        addEdge(edges, new Edge(input, Mode.X12, from, 3, previous));</b>
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      addEdge(edges, new Edge(input, Mode.B256, from, 1, previous));</b>
&nbsp;    }
&nbsp;
&nbsp;    //We create 4 EDF edges,  with 1, 2 3 or 4 characters length. The fourth normally doesn&#39;t have a latch to ASCII
&nbsp;    //unless it is 2 characters away from the end of the input.
&nbsp;    int i;
<b class="fc">&nbsp;    for (i = 0; i &lt; 3; i++) {</b>
<b class="fc">&nbsp;      int pos = from + i;</b>
<b class="fc">&nbsp;      if (input.haveNCharacters(pos,1) &amp;&amp; HighLevelEncoder.isNativeEDIFACT(input.charAt(pos))) {</b>
<b class="fc">&nbsp;        addEdge(edges, new Edge(input, Mode.EDF, from, i + 1, previous));</b>
&nbsp;      } else {
&nbsp;        break;
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    if (i == 3 &amp;&amp; input.haveNCharacters(from, 4) &amp;&amp; HighLevelEncoder.isNativeEDIFACT(input.charAt(from + 3))) {</b>
<b class="fc">&nbsp;      addEdge(edges, new Edge(input, Mode.EDF, from, 4, previous));</b>
&nbsp;    }
&nbsp;  }
&nbsp;  static Result encodeMinimally(Input input) {
&nbsp;
&nbsp;    @SuppressWarnings(&quot;checkstyle:lineLength&quot;)
&nbsp;    /* The minimal encoding is computed by Dijkstra. The acyclic graph is modeled as follows:
&nbsp;     * A vertex represents a combination of a position in the input and an encoding mode where position 0
&nbsp;     * denotes the position left of the first character, 1 the position left of the second character and so on.
&nbsp;     * Likewise the end vertices are located after the last character at position input.length().
&nbsp;     * For any position there might be up to six vertices, one for each of the encoding types ASCII, C40, TEXT, X12,
&nbsp;     * EDF and B256.
&nbsp;     *
&nbsp;     * As an example consider the input string &quot;ABC123&quot; then at position 0 there is only one vertex with the default
&nbsp;     * ASCII encodation. At position 3 there might be vertices for the types ASCII, C40, X12, EDF and B256.
&nbsp;     *
&nbsp;     * An edge leading to such a vertex encodes one or more of the characters left of the position that the vertex
&nbsp;     * represents. It encodes the characters in the encoding mode of the vertex that it ends on. In other words,
&nbsp;     * all edges leading to a particular vertex encode the same characters (the length of the suffix can vary) using the same
&nbsp;     * encoding mode.
&nbsp;     * As an example consider the input string &quot;ABC123&quot; and the vertex (4,EDF). Possible edges leading to this vertex
&nbsp;     * are:
&nbsp;     *   (0,ASCII)  --EDF(ABC1)--&gt; (4,EDF)
&nbsp;     *   (1,ASCII)  --EDF(BC1)--&gt;  (4,EDF)
&nbsp;     *   (1,B256)   --EDF(BC1)--&gt;  (4,EDF)
&nbsp;     *   (1,EDF)    --EDF(BC1)--&gt;  (4,EDF)
&nbsp;     *   (2,ASCII)  --EDF(C1)--&gt;   (4,EDF)
&nbsp;     *   (2,B256)   --EDF(C1)--&gt;   (4,EDF)
&nbsp;     *   (2,EDF)    --EDF(C1)--&gt;   (4,EDF)
&nbsp;     *   (3,ASCII)  --EDF(1)--&gt;    (4,EDF)
&nbsp;     *   (3,B256)   --EDF(1)--&gt;    (4,EDF)
&nbsp;     *   (3,EDF)    --EDF(1)--&gt;    (4,EDF)
&nbsp;     *   (3,C40)    --EDF(1)--&gt;    (4,EDF)
&nbsp;     *   (3,X12)    --EDF(1)--&gt;    (4,EDF)
&nbsp;     *
&nbsp;     * The edges leading to a vertex are stored in such a way that there is a fast way to enumerate the edges ending
&nbsp;     * on a particular vertex.
&nbsp;     *
&nbsp;     * The algorithm processes the vertices in order of their position thereby performing the following:
&nbsp;     *
&nbsp;     * For every vertex at position i the algorithm enumerates the edges ending on the vertex and removes all but the
&nbsp;     * shortest from that list.
&nbsp;     * Then it processes the vertices for the position i+1. If i+1 == input.length() then the algorithm ends
&nbsp;     * and chooses the the edge with the smallest size from any of the edges leading to vertices at this position.
&nbsp;     * Otherwise the algorithm computes all possible outgoing edges for the vertices at the position i+1
&nbsp;     *
&nbsp;     * Examples:
&nbsp;     * The process is illustrated by showing the graph (edges) after each iteration from left to right over the input:
&nbsp;     * An edge is drawn as follows &quot;(&quot; + fromVertex + &quot;) -- &quot; + encodingMode + &quot;(&quot; + encodedInput + &quot;) (&quot; +
&nbsp;     * accumulatedSize + &quot;) --&gt; (&quot; + toVertex + &quot;)&quot;
&nbsp;     *
&nbsp;     * Example 1 encoding the string &quot;ABCDEFG&quot;:
&nbsp;     *
&nbsp;     *
&nbsp;     * Situation after adding edges to the start vertex (0,ASCII)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256)
&nbsp;     * (0,ASCII) EDF(AB) (4) --&gt; (2,EDF)
&nbsp;     * (0,ASCII) C40(ABC) (3) --&gt; (3,C40)
&nbsp;     * (0,ASCII) TEXT(ABC) (5) --&gt; (3,TEXT)
&nbsp;     * (0,ASCII) X12(ABC) (3) --&gt; (3,X12)
&nbsp;     * (0,ASCII) EDF(ABC) (4) --&gt; (3,EDF)
&nbsp;     * (0,ASCII) EDF(ABCD) (4) --&gt; (4,EDF)
&nbsp;     *
&nbsp;     * Situation after adding edges to vertices at position 1
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256)
&nbsp;     * (0,ASCII) EDF(AB) (4) --&gt; (2,EDF)
&nbsp;     * (0,ASCII) C40(ABC) (3) --&gt; (3,C40)
&nbsp;     * (0,ASCII) TEXT(ABC) (5) --&gt; (3,TEXT)
&nbsp;     * (0,ASCII) X12(ABC) (3) --&gt; (3,X12)
&nbsp;     * (0,ASCII) EDF(ABC) (4) --&gt; (3,EDF)
&nbsp;     * (0,ASCII) EDF(ABCD) (4) --&gt; (4,EDF)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) B256(B) (4) --&gt; (2,B256)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) EDF(BC) (5) --&gt; (3,EDF)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) C40(BCD) (4) --&gt; (4,C40)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) TEXT(BCD) (6) --&gt; (4,TEXT)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) X12(BCD) (4) --&gt; (4,X12)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) EDF(BCD) (5) --&gt; (4,EDF)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) EDF(BCDE) (5) --&gt; (5,EDF)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) ASCII(B) (4) --&gt; (2,ASCII)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) B256(B) (3) --&gt; (2,B256)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) EDF(BC) (6) --&gt; (3,EDF)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) C40(BCD) (5) --&gt; (4,C40)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) TEXT(BCD) (7) --&gt; (4,TEXT)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) X12(BCD) (5) --&gt; (4,X12)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) EDF(BCD) (6) --&gt; (4,EDF)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) EDF(BCDE) (6) --&gt; (5,EDF)
&nbsp;     *
&nbsp;     * Edge &quot;(1,ASCII) ASCII(B) (2) --&gt; (2,ASCII)&quot; is minimal for the vertex (2,ASCII) so that edge &quot;(1,B256) ASCII(B) (4) --&gt; (2,ASCII)&quot; is removed.
&nbsp;     * Edge &quot;(1,B256) B256(B) (3) --&gt; (2,B256)&quot; is minimal for the vertext (2,B256) so that the edge &quot;(1,ASCII) B256(B) (4) --&gt; (2,B256)&quot; is removed.
&nbsp;     *
&nbsp;     * Situation after adding edges to vertices at position 2
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256)
&nbsp;     * (0,ASCII) EDF(AB) (4) --&gt; (2,EDF)
&nbsp;     * (0,ASCII) C40(ABC) (3) --&gt; (3,C40)
&nbsp;     * (0,ASCII) TEXT(ABC) (5) --&gt; (3,TEXT)
&nbsp;     * (0,ASCII) X12(ABC) (3) --&gt; (3,X12)
&nbsp;     * (0,ASCII) EDF(ABC) (4) --&gt; (3,EDF)
&nbsp;     * (0,ASCII) EDF(ABCD) (4) --&gt; (4,EDF)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) EDF(BC) (5) --&gt; (3,EDF)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) C40(BCD) (4) --&gt; (4,C40)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) TEXT(BCD) (6) --&gt; (4,TEXT)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) X12(BCD) (4) --&gt; (4,X12)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) EDF(BCD) (5) --&gt; (4,EDF)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) EDF(BCDE) (5) --&gt; (5,EDF)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) B256(B) (3) --&gt; (2,B256)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) EDF(BC) (6) --&gt; (3,EDF)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) C40(BCD) (5) --&gt; (4,C40)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) TEXT(BCD) (7) --&gt; (4,TEXT)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) X12(BCD) (5) --&gt; (4,X12)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) EDF(BCD) (6) --&gt; (4,EDF)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) EDF(BCDE) (6) --&gt; (5,EDF)
&nbsp;     * (0,ASCII) EDF(AB) (4) --&gt; (2,EDF) ASCII(C) (5) --&gt; (3,ASCII)
&nbsp;     * (0,ASCII) EDF(AB) (4) --&gt; (2,EDF) B256(C) (6) --&gt; (3,B256)
&nbsp;     * (0,ASCII) EDF(AB) (4) --&gt; (2,EDF) EDF(CD) (7) --&gt; (4,EDF)
&nbsp;     * (0,ASCII) EDF(AB) (4) --&gt; (2,EDF) C40(CDE) (6) --&gt; (5,C40)
&nbsp;     * (0,ASCII) EDF(AB) (4) --&gt; (2,EDF) TEXT(CDE) (8) --&gt; (5,TEXT)
&nbsp;     * (0,ASCII) EDF(AB) (4) --&gt; (2,EDF) X12(CDE) (6) --&gt; (5,X12)
&nbsp;     * (0,ASCII) EDF(AB) (4) --&gt; (2,EDF) EDF(CDE) (7) --&gt; (5,EDF)
&nbsp;     * (0,ASCII) EDF(AB) (4) --&gt; (2,EDF) EDF(CDEF) (7) --&gt; (6,EDF)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) ASCII(C) (3) --&gt; (3,ASCII)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) B256(C) (5) --&gt; (3,B256)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) EDF(CD) (6) --&gt; (4,EDF)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) C40(CDE) (5) --&gt; (5,C40)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) TEXT(CDE) (7) --&gt; (5,TEXT)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) X12(CDE) (5) --&gt; (5,X12)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) EDF(CDE) (6) --&gt; (5,EDF)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) EDF(CDEF) (6) --&gt; (6,EDF)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) B256(B) (3) --&gt; (2,B256) ASCII(C) (4) --&gt; (3,ASCII)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) B256(B) (3) --&gt; (2,B256) B256(C) (4) --&gt; (3,B256)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) B256(B) (3) --&gt; (2,B256) EDF(CD) (6) --&gt; (4,EDF)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) B256(B) (3) --&gt; (2,B256) C40(CDE) (5) --&gt; (5,C40)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) B256(B) (3) --&gt; (2,B256) TEXT(CDE) (7) --&gt; (5,TEXT)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) B256(B) (3) --&gt; (2,B256) X12(CDE) (5) --&gt; (5,X12)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) B256(B) (3) --&gt; (2,B256) EDF(CDE) (6) --&gt; (5,EDF)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) B256(B) (3) --&gt; (2,B256) EDF(CDEF) (6) --&gt; (6,EDF)
&nbsp;     *
&nbsp;     * Edge &quot;(2,ASCII) ASCII(C) (3) --&gt; (3,ASCII)&quot; is minimal for the vertex (3,ASCII) so that edges &quot;(2,EDF) ASCII(C) (5) --&gt; (3,ASCII)&quot;
&nbsp;     * and &quot;(2,B256) ASCII(C) (4) --&gt; (3,ASCII)&quot; can be removed.
&nbsp;     * Edge &quot;(0,ASCII) EDF(ABC) (4) --&gt; (3,EDF)&quot; is minimal for the vertex (3,EDF) so that edges &quot;(1,ASCII) EDF(BC) (5) --&gt; (3,EDF)&quot;
&nbsp;     * and &quot;(1,B256) EDF(BC) (6) --&gt; (3,EDF)&quot; can be removed.
&nbsp;     * Edge &quot;(2,B256) B256(C) (4) --&gt; (3,B256)&quot; is minimal for the vertex (3,B256) so that edges &quot;(2,ASCII) B256(C) (5) --&gt; (3,B256)&quot;
&nbsp;     * and &quot;(2,EDF) B256(C) (6) --&gt; (3,B256)&quot; can be removed.
&nbsp;     *
&nbsp;     * This continues for vertices 3 thru 7
&nbsp;     *
&nbsp;     * Situation after adding edges to vertices at position 7
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256)
&nbsp;     * (0,ASCII) EDF(AB) (4) --&gt; (2,EDF)
&nbsp;     * (0,ASCII) C40(ABC) (3) --&gt; (3,C40)
&nbsp;     * (0,ASCII) TEXT(ABC) (5) --&gt; (3,TEXT)
&nbsp;     * (0,ASCII) X12(ABC) (3) --&gt; (3,X12)
&nbsp;     * (0,ASCII) EDF(ABC) (4) --&gt; (3,EDF)
&nbsp;     * (0,ASCII) EDF(ABCD) (4) --&gt; (4,EDF)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) C40(BCD) (4) --&gt; (4,C40)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) TEXT(BCD) (6) --&gt; (4,TEXT)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) X12(BCD) (4) --&gt; (4,X12)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) EDF(BCDE) (5) --&gt; (5,EDF)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) B256(B) (3) --&gt; (2,B256)
&nbsp;     * (0,ASCII) C40(ABC) (3) --&gt; (3,C40) C40(DEF) (5) --&gt; (6,C40)
&nbsp;     * (0,ASCII) X12(ABC) (3) --&gt; (3,X12) X12(DEF) (5) --&gt; (6,X12)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) ASCII(C) (3) --&gt; (3,ASCII)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) C40(CDE) (5) --&gt; (5,C40)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) TEXT(CDE) (7) --&gt; (5,TEXT)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) X12(CDE) (5) --&gt; (5,X12)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) EDF(CDEF) (6) --&gt; (6,EDF)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) C40(BCD) (4) --&gt; (4,C40) C40(EFG) (6) --&gt; (7,C40)    //Solution 1
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) X12(BCD) (4) --&gt; (4,X12) X12(EFG) (6) --&gt; (7,X12)    //Solution 2
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) B256(B) (3) --&gt; (2,B256) B256(C) (4) --&gt; (3,B256)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) ASCII(C) (3) --&gt; (3,ASCII) ASCII(D) (4) --&gt; (4,ASCII)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) ASCII(C) (3) --&gt; (3,ASCII) TEXT(DEF) (8) --&gt; (6,TEXT)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) ASCII(C) (3) --&gt; (3,ASCII) EDF(DEFG) (7) --&gt; (7,EDF)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) B256(B) (3) --&gt; (2,B256) B256(C) (4) --&gt; (3,B256) B256(D) (5) --&gt; (4,B256)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) ASCII(C) (3) --&gt; (3,ASCII) ASCII(D) (4) --&gt; (4,ASCII) ASCII(E) (5) --&gt; (5,ASCII)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) ASCII(C) (3) --&gt; (3,ASCII) ASCII(D) (4) --&gt; (4,ASCII) TEXT(EFG) (9) --&gt; (7,TEXT)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) B256(B) (3) --&gt; (2,B256) B256(C) (4) --&gt; (3,B256) B256(D) (5) --&gt; (4,B256) B256(E) (6) --&gt; (5,B256)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) ASCII(C) (3) --&gt; (3,ASCII) ASCII(D) (4) --&gt; (4,ASCII) ASCII(E) (5) --&gt; (5,ASCII) ASCII(F) (6) --&gt; (6,ASCII)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) B256(B) (3) --&gt; (2,B256) B256(C) (4) --&gt; (3,B256) B256(D) (5) --&gt; (4,B256) B256(E) (6) --&gt; (5,B256) B256(F) (7) --&gt; (6,B256)
&nbsp;     * (0,ASCII) ASCII(A) (1) --&gt; (1,ASCII) ASCII(B) (2) --&gt; (2,ASCII) ASCII(C) (3) --&gt; (3,ASCII) ASCII(D) (4) --&gt; (4,ASCII) ASCII(E) (5) --&gt; (5,ASCII) ASCII(F) (6) --&gt; (6,ASCII) ASCII(G) (7) --&gt; (7,ASCII)
&nbsp;     * (0,ASCII) B256(A) (3) --&gt; (1,B256) B256(B) (3) --&gt; (2,B256) B256(C) (4) --&gt; (3,B256) B256(D) (5) --&gt; (4,B256) B256(E) (6) --&gt; (5,B256) B256(F) (7) --&gt; (6,B256) B256(G) (8) --&gt; (7,B256)
&nbsp;     *
&nbsp;     * Hence a minimal encoding of &quot;ABCDEFG&quot; is either ASCII(A),C40(BCDEFG) or ASCII(A), X12(BCDEFG) with a size of 5 bytes.
&nbsp;     */
&nbsp;
<b class="fc">&nbsp;    int inputLength = input.length();</b>
&nbsp;
&nbsp;    // Array that represents vertices. There is a vertex for every character and mode.
&nbsp;    // The last dimension in the array below encodes the 6 modes ASCII, C40, TEXT, X12, EDF and B256
<b class="fc">&nbsp;    Edge[][] edges = new Edge[inputLength + 1][6];</b>
<b class="fc">&nbsp;    addEdges(input, edges, 0, null);</b>
&nbsp;
<b class="fc">&nbsp;    for (int i = 1; i &lt;= inputLength; i++) {</b>
<b class="fc">&nbsp;      for (int j = 0; j &lt; 6; j++) {</b>
<b class="fc">&nbsp;        if (edges[i][j] != null &amp;&amp; i &lt; inputLength) {</b>
<b class="fc">&nbsp;          addEdges(input, edges, i, edges[i][j]);</b>
&nbsp;        }
&nbsp;      }
&nbsp;      //optimize memory by removing edges that have been passed.
<b class="fc">&nbsp;      for (int j = 0; j &lt; 6; j++) {</b>
<b class="fc">&nbsp;        edges[i - 1][j] = null;</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    int minimalJ = -1;</b>
<b class="fc">&nbsp;    int minimalSize = Integer.MAX_VALUE;</b>
<b class="fc">&nbsp;    for (int j = 0; j &lt; 6; j++) {</b>
<b class="fc">&nbsp;      if (edges[inputLength][j] != null) {</b>
<b class="fc">&nbsp;        Edge edge = edges[inputLength][j];</b>
<b class="fc">&nbsp;        int size = j &gt;= 1 &amp;&amp; j &lt;= 3 ? edge.cachedTotalSize + 1 : edge.cachedTotalSize; //C40, TEXT and X12 need an</b>
&nbsp;                                                                                       // extra unlatch at the end
<b class="fc">&nbsp;        if (size &lt; minimalSize) {</b>
<b class="fc">&nbsp;          minimalSize = size;</b>
<b class="fc">&nbsp;          minimalJ = j;</b>
&nbsp;        }
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    if (minimalJ &lt; 0) {</b>
<b class="nc">&nbsp;      throw new IllegalStateException(&quot;Failed to encode \&quot;&quot; + input + &quot;\&quot;&quot;);</b>
&nbsp;    }
<b class="fc">&nbsp;    return new Result(edges[inputLength][minimalJ]);</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  private static final class Edge {</b>
<b class="fc">&nbsp;    private static final int[] allCodewordCapacities = {3, 5, 8, 10, 12, 16, 18, 22, 30, 32, 36, 44, 49, 62, 86, 114,</b>
&nbsp;                                                        144, 174, 204, 280, 368, 456, 576, 696, 816, 1050, 1304, 1558};
<b class="fc">&nbsp;    private static final int[] squareCodewordCapacities = {3, 5, 8, 12, 18, 22, 30, 36, 44, 62, 86, 114, 144, 174, 204,</b>
&nbsp;                                                           280, 368, 456, 576, 696, 816, 1050, 1304, 1558};
<b class="fc">&nbsp;    private static final int[] rectangularCodewordCapacities = {5, 10, 16, 33, 32, 49};</b>
&nbsp;    private final Input input;
&nbsp;    private final Mode mode; //the mode at the start of this edge.
&nbsp;    private final int fromPosition;
&nbsp;    private final int characterLength;
&nbsp;    private final Edge previous;
&nbsp;    private final int cachedTotalSize;
&nbsp;
<b class="fc">&nbsp;    private Edge(Input input, Mode mode, int fromPosition, int characterLength, Edge previous) {</b>
<b class="fc">&nbsp;      this.input = input;</b>
<b class="fc">&nbsp;      this.mode = mode;</b>
<b class="fc">&nbsp;      this.fromPosition = fromPosition;</b>
<b class="fc">&nbsp;      this.characterLength = characterLength;</b>
<b class="fc">&nbsp;      this.previous = previous;</b>
<b class="fc">&nbsp;      assert fromPosition + characterLength &lt;= input.length();</b>
&nbsp;
<b class="fc">&nbsp;      int size = previous != null ? previous.cachedTotalSize : 0;</b>
&nbsp;
<b class="fc">&nbsp;      Mode previousMode = getPreviousMode();</b>
&nbsp;
&nbsp;     /*
&nbsp;      * Switching modes
&nbsp;      * ASCII -&gt; C40: latch 230
&nbsp;      * ASCII -&gt; TEXT: latch 239
&nbsp;      * ASCII -&gt; X12: latch 238
&nbsp;      * ASCII -&gt; EDF: latch 240
&nbsp;      * ASCII -&gt; B256: latch 231
&nbsp;      * C40 -&gt; ASCII: word(c1,c2,c3), 254
&nbsp;      * TEXT -&gt; ASCII: word(c1,c2,c3), 254
&nbsp;      * X12 -&gt; ASCII: word(c1,c2,c3), 254
&nbsp;      * EDIFACT -&gt; ASCII: Unlatch character,0,0,0 or c1,Unlatch character,0,0 or c1,c2,Unlatch character,0 or
&nbsp;      * c1,c2,c3,Unlatch character
&nbsp;      * B256 -&gt; ASCII: without latch after n bytes
&nbsp;      */
<b class="fc">&nbsp;      switch (mode) {</b>
&nbsp;        case ASCII:
<b class="fc">&nbsp;          size++;</b>
<b class="fc">&nbsp;          if (input.isECI(fromPosition) || isExtendedASCII(input.charAt(fromPosition), input.getFNC1Character())) {</b>
<b class="fc">&nbsp;            size++;</b>
&nbsp;          }
<b class="fc">&nbsp;          if (previousMode == Mode.C40 ||</b>
&nbsp;              previousMode == Mode.TEXT ||
&nbsp;              previousMode == Mode.X12) {
<b class="fc">&nbsp;            size++; // unlatch 254 to ASCII</b>
&nbsp;          }
&nbsp;          break;
&nbsp;        case B256:
<b class="fc">&nbsp;          size++;</b>
<b class="fc">&nbsp;          if (previousMode != Mode.B256) {</b>
<b class="fc">&nbsp;            size++; //byte count</b>
<b class="fc">&nbsp;          } else if (getB256Size() == 250) {</b>
<b class="fc">&nbsp;            size++; //extra byte count</b>
&nbsp;          }
<b class="fc">&nbsp;          if (previousMode == Mode.ASCII) {</b>
<b class="fc">&nbsp;            size++; //latch to B256</b>
<b class="fc">&nbsp;          } else if (previousMode == Mode.C40 ||</b>
&nbsp;                     previousMode == Mode.TEXT ||
&nbsp;                     previousMode == Mode.X12) {
<b class="fc">&nbsp;            size += 2; //unlatch to ASCII, latch to B256</b>
&nbsp;          }
&nbsp;          break;
&nbsp;        case C40:
&nbsp;        case TEXT:
&nbsp;        case X12:
<b class="fc">&nbsp;          if (mode == Mode.X12) {</b>
<b class="fc">&nbsp;            size += 2;</b>
&nbsp;          } else {
<b class="fc">&nbsp;            int[] charLen = new int[1];</b>
<b class="fc">&nbsp;            size += getNumberOfC40Words(input, fromPosition, mode == Mode.C40, charLen) * 2;</b>
&nbsp;          }
&nbsp;
<b class="fc">&nbsp;          if (previousMode == Mode.ASCII || previousMode == Mode.B256) {</b>
<b class="fc">&nbsp;            size++; //additional byte for latch from ASCII to this mode</b>
<b class="fc">&nbsp;          } else if (previousMode != mode &amp;&amp; (previousMode == Mode.C40 ||</b>
&nbsp;                                             previousMode == Mode.TEXT ||
&nbsp;                                             previousMode == Mode.X12)) {
<b class="fc">&nbsp;            size += 2; //unlatch 254 to ASCII followed by latch to this mode</b>
&nbsp;          }
&nbsp;          break;
&nbsp;        case EDF:
<b class="fc">&nbsp;          size += 3;</b>
<b class="fc">&nbsp;          if (previousMode == Mode.ASCII || previousMode == Mode.B256) {</b>
<b class="fc">&nbsp;            size++; //additional byte for latch from ASCII to this mode</b>
<b class="fc">&nbsp;          } else if (previousMode == Mode.C40 ||</b>
&nbsp;                    previousMode == Mode.TEXT ||
&nbsp;                    previousMode == Mode.X12) {
<b class="fc">&nbsp;            size += 2; //unlatch 254 to ASCII followed by latch to this mode</b>
&nbsp;          }
&nbsp;          break;
&nbsp;      }
<b class="fc">&nbsp;      cachedTotalSize = size;</b>
&nbsp;    }
&nbsp;
&nbsp;    // does not count beyond 250
&nbsp;    int getB256Size() {
<b class="fc">&nbsp;      int cnt = 0;</b>
<b class="fc">&nbsp;      Edge current = this;</b>
<b class="fc">&nbsp;      while (current != null &amp;&amp; current.mode == Mode.B256 &amp;&amp; cnt &lt;= 250) {</b>
<b class="fc">&nbsp;        cnt++;</b>
<b class="fc">&nbsp;        current = current.previous;</b>
&nbsp;      }
<b class="fc">&nbsp;      return cnt;</b>
&nbsp;    }
&nbsp;
&nbsp;    Mode getPreviousStartMode() {
<b class="fc">&nbsp;      return  previous == null ? Mode.ASCII : previous.mode;</b>
&nbsp;    }
&nbsp;
&nbsp;    Mode getPreviousMode() {
<b class="fc">&nbsp;      return  previous == null ? Mode.ASCII : previous.getEndMode();</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Returns Mode.ASCII in case that:
&nbsp;     *  - Mode is EDIFACT and characterLength is less than 4 or the remaining characters can be encoded in at most 2
&nbsp;     *    ASCII bytes.
&nbsp;     *  - Mode is C40, TEXT or X12 and the remaining characters can be encoded in at most 1 ASCII byte.
&nbsp;     *  Returns mode in all other cases.
&nbsp;     * */
&nbsp;    Mode getEndMode() {
<b class="fc">&nbsp;      if (mode == Mode.EDF) {</b>
<b class="fc">&nbsp;        if (characterLength &lt; 4) {</b>
<b class="fc">&nbsp;          return Mode.ASCII;</b>
&nbsp;        }
<b class="fc">&nbsp;        int lastASCII = getLastASCII(); // see 5.2.8.2 EDIFACT encodation Rules</b>
<b class="fc">&nbsp;        if (lastASCII &gt; 0 &amp;&amp; getCodewordsRemaining(cachedTotalSize + lastASCII) &lt;= 2 - lastASCII) {</b>
<b class="fc">&nbsp;          return Mode.ASCII;</b>
&nbsp;        }
&nbsp;      }
<b class="fc">&nbsp;      if (mode == Mode.C40 ||</b>
&nbsp;          mode == Mode.TEXT ||
&nbsp;          mode == Mode.X12) {
&nbsp;
&nbsp;        // see 5.2.5.2 C40 encodation rules and 5.2.7.2 ANSI X12 encodation rules
<b class="fc">&nbsp;        if (fromPosition + characterLength &gt;= input.length() &amp;&amp; getCodewordsRemaining(cachedTotalSize) == 0) {</b>
<b class="fc">&nbsp;          return Mode.ASCII;</b>
&nbsp;        }
<b class="fc">&nbsp;        int lastASCII = getLastASCII();</b>
<b class="fc">&nbsp;        if (lastASCII == 1 &amp;&amp; getCodewordsRemaining(cachedTotalSize + 1) == 0) {</b>
<b class="fc">&nbsp;          return Mode.ASCII;</b>
&nbsp;        }
&nbsp;      }
<b class="fc">&nbsp;      return mode;</b>
&nbsp;    }
&nbsp;
&nbsp;    Mode getMode() {
<b class="fc">&nbsp;      return mode;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Peeks ahead and returns 1 if the postfix consists of exactly two digits, 2 if the postfix consists of exactly
&nbsp;     *  two consecutive digits and a non extended character or of 4 digits.
&nbsp;     *  Returns 0 in any other case
&nbsp;     **/
&nbsp;    int getLastASCII() {
<b class="fc">&nbsp;      int length = input.length();</b>
<b class="fc">&nbsp;      int from = fromPosition + characterLength;</b>
<b class="fc">&nbsp;      if (length - from &gt; 4 || from &gt;= length) {</b>
<b class="fc">&nbsp;        return 0;</b>
&nbsp;      }
<b class="fc">&nbsp;      if (length - from == 1) {</b>
<b class="fc">&nbsp;        if (isExtendedASCII(input.charAt(from), input.getFNC1Character())) {</b>
<b class="fc">&nbsp;          return 0;</b>
&nbsp;        }
<b class="fc">&nbsp;        return 1;</b>
&nbsp;      }
<b class="fc">&nbsp;      if (length - from == 2) {</b>
<b class="fc">&nbsp;        if (isExtendedASCII(input.charAt(from), input.getFNC1Character()) || isExtendedASCII(input.charAt(from + 1),</b>
<b class="fc">&nbsp;            input.getFNC1Character())) {</b>
<b class="fc">&nbsp;          return 0;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (HighLevelEncoder.isDigit(input.charAt(from)) &amp;&amp; HighLevelEncoder.isDigit(input.charAt(from + 1))) {</b>
<b class="fc">&nbsp;          return 1;</b>
&nbsp;        }
<b class="fc">&nbsp;        return 2;</b>
&nbsp;      }
<b class="fc">&nbsp;      if (length - from == 3) {</b>
<b class="fc">&nbsp;        if (HighLevelEncoder.isDigit(input.charAt(from)) &amp;&amp; HighLevelEncoder.isDigit(input.charAt(from + 1))</b>
<b class="fc">&nbsp;            &amp;&amp; !isExtendedASCII(input.charAt(from + 2), input.getFNC1Character())) {</b>
<b class="fc">&nbsp;          return 2;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (HighLevelEncoder.isDigit(input.charAt(from + 1)) &amp;&amp; HighLevelEncoder.isDigit(input.charAt(from + 2))</b>
<b class="fc">&nbsp;            &amp;&amp; !isExtendedASCII(input.charAt(from), input.getFNC1Character())) {</b>
<b class="fc">&nbsp;          return 2;</b>
&nbsp;        }
<b class="fc">&nbsp;        return 0;</b>
&nbsp;      }
<b class="fc">&nbsp;      if (HighLevelEncoder.isDigit(input.charAt(from)) &amp;&amp; HighLevelEncoder.isDigit(input.charAt(from + 1))</b>
<b class="fc">&nbsp;          &amp;&amp; HighLevelEncoder.isDigit(input.charAt(from + 2)) &amp;&amp; HighLevelEncoder.isDigit(input.charAt(from + 3))) {</b>
<b class="fc">&nbsp;        return 2;</b>
&nbsp;      }
<b class="fc">&nbsp;      return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Returns the capacity in codewords of the smallest symbol that has enough capacity to fit the given minimal
&nbsp;     * number of codewords.
&nbsp;     **/
&nbsp;    int getMinSymbolSize(int minimum) {
<b class="fc">&nbsp;      switch (input.getShapeHint()) {</b>
&nbsp;        case FORCE_SQUARE:
<b class="nc">&nbsp;          for (int capacity : squareCodewordCapacities) {</b>
<b class="nc">&nbsp;            if (capacity &gt;= minimum) {</b>
<b class="nc">&nbsp;              return capacity;</b>
&nbsp;            }
&nbsp;          }
<b class="nc">&nbsp;          break;</b>
&nbsp;        case FORCE_RECTANGLE:
<b class="nc">&nbsp;          for (int capacity : rectangularCodewordCapacities) {</b>
<b class="nc">&nbsp;            if (capacity &gt;= minimum) {</b>
<b class="nc">&nbsp;              return capacity;</b>
&nbsp;            }
&nbsp;          }
&nbsp;          break;
&nbsp;      }
<b class="fc">&nbsp;      for (int capacity : allCodewordCapacities) {</b>
<b class="fc">&nbsp;        if (capacity &gt;= minimum) {</b>
<b class="fc">&nbsp;          return capacity;</b>
&nbsp;        }
&nbsp;      }
<b class="nc">&nbsp;      return allCodewordCapacities[allCodewordCapacities.length - 1];</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Returns the remaining capacity in codewords of the smallest symbol that has enough capacity to fit the given
&nbsp;     * minimal number of codewords.
&nbsp;     **/
&nbsp;    int getCodewordsRemaining(int minimum) {
<b class="fc">&nbsp;      return getMinSymbolSize(minimum) - minimum;</b>
&nbsp;    }
&nbsp;
&nbsp;    static byte[] getBytes(int c) {
<b class="fc">&nbsp;      byte[] result = new byte[1];</b>
<b class="fc">&nbsp;      result[0] = (byte) c;</b>
<b class="fc">&nbsp;      return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    static byte[] getBytes(int c1,int c2) {
<b class="fc">&nbsp;      byte[] result = new byte[2];</b>
<b class="fc">&nbsp;      result[0] = (byte) c1;</b>
<b class="fc">&nbsp;      result[1] = (byte) c2;</b>
<b class="fc">&nbsp;      return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    static void setC40Word(byte[] bytes, int offset, int c1, int c2, int c3) {
<b class="fc">&nbsp;      int val16 = (1600 * (c1 &amp; 0xff)) + (40 * (c2 &amp; 0xff)) + (c3 &amp; 0xff) + 1;</b>
<b class="fc">&nbsp;      bytes[offset] = (byte) (val16 / 256);</b>
<b class="fc">&nbsp;      bytes[offset + 1] = (byte) (val16 % 256);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static int getX12Value(char c) {
<b class="fc">&nbsp;      return c == 13 ? 0 :</b>
<b class="fc">&nbsp;             c == 42 ? 1 :</b>
<b class="fc">&nbsp;             c == 62 ? 2 :</b>
<b class="fc">&nbsp;             c == 32 ? 3 :</b>
<b class="fc">&nbsp;             c &gt;= 48 &amp;&amp; c &lt;= 57 ? c - 44 :</b>
<b class="fc">&nbsp;             c &gt;= 65 &amp;&amp; c &lt;= 90 ? c - 51 : c;</b>
&nbsp;    }
&nbsp;
&nbsp;    byte[] getX12Words() {
<b class="fc">&nbsp;      assert characterLength % 3 == 0;</b>
<b class="fc">&nbsp;      byte[] result = new byte[characterLength / 3 * 2];</b>
<b class="fc">&nbsp;      for (int i = 0; i &lt; result.length; i += 2) {</b>
<b class="fc">&nbsp;        setC40Word(result,i,getX12Value(input.charAt(fromPosition + i / 2 * 3)),</b>
<b class="fc">&nbsp;                              getX12Value(input.charAt(fromPosition + i / 2 * 3 + 1)),</b>
<b class="fc">&nbsp;                              getX12Value(input.charAt(fromPosition + i / 2 * 3 + 2)));</b>
&nbsp;      }
<b class="fc">&nbsp;      return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    static int getShiftValue(char c, boolean c40, int fnc1) {
<b class="fc">&nbsp;      return (c40 &amp;&amp; isInC40Shift1Set(c) ||</b>
<b class="fc">&nbsp;             !c40 &amp;&amp; isInTextShift1Set(c)) ? 0 :</b>
<b class="fc">&nbsp;             (c40 &amp;&amp; isInC40Shift2Set(c, fnc1) ||</b>
<b class="fc">&nbsp;             !c40 &amp;&amp; isInTextShift2Set(c, fnc1)) ? 1 : 2;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static int getC40Value(boolean c40, int setIndex, char c, int fnc1) {
<b class="fc">&nbsp;      if (c == fnc1) {</b>
<b class="nc">&nbsp;        assert setIndex ==  2;</b>
<b class="nc">&nbsp;        return  27;</b>
&nbsp;      }
<b class="fc">&nbsp;      if (c40) {</b>
<b class="fc">&nbsp;        return c &lt;= 31 ? c :</b>
<b class="fc">&nbsp;               c == 32 ? 3 :</b>
<b class="fc">&nbsp;               c &lt;= 47 ? c - 33 :</b>
<b class="fc">&nbsp;               c &lt;= 57 ? c - 44 :</b>
<b class="fc">&nbsp;               c &lt;= 64 ? c - 43 :</b>
<b class="fc">&nbsp;               c &lt;= 90 ? c - 51 :</b>
<b class="fc">&nbsp;               c &lt;= 95 ? c - 69 :</b>
<b class="fc">&nbsp;               c &lt;= 127 ? c - 96 : c;</b>
&nbsp;      } else {
<b class="fc">&nbsp;        return c == 0 ? 0 :</b>
<b class="fc">&nbsp;               setIndex == 0 &amp;&amp; c &lt;= 3 ? c - 1 : //is this a bug in the spec?</b>
<b class="fc">&nbsp;               setIndex == 1 &amp;&amp; c &lt;= 31 ? c :</b>
<b class="fc">&nbsp;               c == 32 ? 3 :</b>
<b class="fc">&nbsp;               c &gt;= 33 &amp;&amp; c &lt;= 47 ? c - 33 :</b>
<b class="fc">&nbsp;               c &gt;= 48 &amp;&amp; c &lt;= 57 ? c - 44 :</b>
<b class="fc">&nbsp;               c &gt;= 58 &amp;&amp; c &lt;= 64 ? c - 43 :</b>
<b class="fc">&nbsp;               c &gt;= 65 &amp;&amp; c &lt;= 90 ? c - 64 :</b>
<b class="fc">&nbsp;               c &gt;= 91 &amp;&amp; c &lt;= 95 ? c - 69 :</b>
<b class="fc">&nbsp;               c == 96 ? 0 :</b>
<b class="fc">&nbsp;               c &gt;= 97 &amp;&amp; c &lt;= 122 ? c - 83 :</b>
<b class="nc">&nbsp;               c &gt;= 123 &amp;&amp; c &lt;= 127 ? c - 96 : c;</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    byte[] getC40Words(boolean c40, int fnc1) {
<b class="fc">&nbsp;      List&lt;Byte&gt; c40Values = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;      for (int i = 0; i &lt; characterLength; i++) {</b>
<b class="fc">&nbsp;        char ci = input.charAt(fromPosition + i);</b>
<b class="fc">&nbsp;        if (c40 &amp;&amp; HighLevelEncoder.isNativeC40(ci) || !c40 &amp;&amp; HighLevelEncoder.isNativeText(ci)) {</b>
<b class="fc">&nbsp;          c40Values.add((byte) getC40Value(c40, 0, ci, fnc1));</b>
<b class="fc">&nbsp;        } else if (!isExtendedASCII(ci, fnc1)) {</b>
<b class="fc">&nbsp;          int shiftValue = getShiftValue(ci, c40, fnc1);</b>
<b class="fc">&nbsp;          c40Values.add((byte) shiftValue); //Shift[123]</b>
<b class="fc">&nbsp;          c40Values.add((byte) getC40Value(c40, shiftValue, ci, fnc1));</b>
<b class="fc">&nbsp;        } else {</b>
<b class="fc">&nbsp;          char asciiValue = (char) ((ci &amp; 0xff) - 128);</b>
<b class="fc">&nbsp;          if (c40 &amp;&amp; HighLevelEncoder.isNativeC40(asciiValue) ||</b>
<b class="nc">&nbsp;              !c40 &amp;&amp; HighLevelEncoder.isNativeText(asciiValue)) {</b>
<b class="fc">&nbsp;            c40Values.add((byte) 1); //Shift 2</b>
<b class="fc">&nbsp;            c40Values.add((byte) 30); //Upper Shift</b>
<b class="fc">&nbsp;            c40Values.add((byte) getC40Value(c40, 0, asciiValue, fnc1));</b>
&nbsp;          } else {
<b class="fc">&nbsp;            c40Values.add((byte) 1); //Shift 2</b>
<b class="fc">&nbsp;            c40Values.add((byte) 30); //Upper Shift</b>
<b class="fc">&nbsp;            int shiftValue = getShiftValue(asciiValue, c40, fnc1);</b>
<b class="fc">&nbsp;            c40Values.add((byte) shiftValue); // Shift[123]</b>
<b class="fc">&nbsp;            c40Values.add((byte) getC40Value(c40, shiftValue, asciiValue, fnc1));</b>
&nbsp;          }
&nbsp;        }
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      if ((c40Values.size() % 3) != 0) {</b>
<b class="fc">&nbsp;        assert (c40Values.size() - 2) % 3 == 0 &amp;&amp; fromPosition + characterLength == input.length();</b>
<b class="fc">&nbsp;        c40Values.add((byte) 0); // pad with 0 (Shift 1)</b>
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      byte[] result = new byte[c40Values.size() / 3 * 2];</b>
<b class="fc">&nbsp;      int byteIndex = 0;</b>
<b class="fc">&nbsp;      for (int i = 0; i &lt; c40Values.size(); i += 3) {</b>
<b class="fc">&nbsp;        setC40Word(result,byteIndex, c40Values.get(i) &amp; 0xff, c40Values.get(i + 1) &amp; 0xff, c40Values.get(i + 2) &amp; 0xff);</b>
<b class="fc">&nbsp;        byteIndex += 2;</b>
&nbsp;      }
<b class="fc">&nbsp;      return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    byte[] getEDFBytes() {
<b class="fc">&nbsp;      int numberOfThirds = (int) Math.ceil(characterLength / 4.0);</b>
<b class="fc">&nbsp;      byte[] result = new byte[numberOfThirds * 3];</b>
<b class="fc">&nbsp;      int pos = fromPosition;</b>
<b class="fc">&nbsp;      int endPos = Math.min(fromPosition + characterLength - 1 , input.length() - 1);</b>
<b class="fc">&nbsp;      for (int i = 0; i &lt; numberOfThirds; i += 3) {</b>
<b class="fc">&nbsp;        int[] edfValues = new int[4];</b>
<b class="fc">&nbsp;        for (int j = 0; j &lt; 4; j++) {</b>
<b class="fc">&nbsp;          if (pos &lt;= endPos) {</b>
<b class="fc">&nbsp;            edfValues[j] = input.charAt(pos++) &amp; 0x3f;</b>
&nbsp;          } else {
<b class="fc">&nbsp;            edfValues[j] = pos == endPos + 1 ? 0x1f : 0;</b>
&nbsp;          }
&nbsp;        }
<b class="fc">&nbsp;        int val24 = edfValues[0] &lt;&lt; 18;</b>
<b class="fc">&nbsp;        val24 |= edfValues[1] &lt;&lt; 12;</b>
<b class="fc">&nbsp;        val24 |= edfValues[2] &lt;&lt; 6;</b>
<b class="fc">&nbsp;        val24 |= edfValues[3];</b>
<b class="fc">&nbsp;        result[i] = (byte) ((val24 &gt;&gt; 16) &amp; 0xff);</b>
<b class="fc">&nbsp;        result[i + 1] = (byte) ((val24 &gt;&gt; 8) &amp; 0xff);</b>
<b class="fc">&nbsp;        result[i + 2] = (byte) (val24 &amp; 0xff);</b>
&nbsp;      }
<b class="fc">&nbsp;      return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    byte[] getLatchBytes() {
<b class="fc">&nbsp;      switch (getPreviousMode()) {</b>
&nbsp;        case ASCII:
&nbsp;        case B256: //after B256 ends (via length) we are back to ASCII
<b class="fc">&nbsp;          switch (mode) {</b>
&nbsp;            case B256:
<b class="fc">&nbsp;              return getBytes(231);</b>
&nbsp;            case C40:
<b class="fc">&nbsp;              return getBytes(230);</b>
&nbsp;            case TEXT:
<b class="fc">&nbsp;              return getBytes(239);</b>
&nbsp;            case X12:
<b class="fc">&nbsp;              return getBytes(238);</b>
&nbsp;            case EDF:
<b class="fc">&nbsp;              return getBytes(240);</b>
&nbsp;          }
<b class="fc">&nbsp;          break;</b>
&nbsp;        case C40:
&nbsp;        case TEXT:
&nbsp;        case X12:
<b class="fc">&nbsp;          if (mode != getPreviousMode()) {</b>
<b class="fc">&nbsp;            switch (mode) {</b>
&nbsp;              case ASCII:
<b class="fc">&nbsp;                return getBytes(254);</b>
&nbsp;              case B256:
<b class="fc">&nbsp;                return getBytes(254, 231);</b>
&nbsp;              case C40:
<b class="nc">&nbsp;                return getBytes(254, 230);</b>
&nbsp;              case TEXT:
<b class="nc">&nbsp;                return getBytes(254, 239);</b>
&nbsp;              case X12:
<b class="nc">&nbsp;                return getBytes(254, 238);</b>
&nbsp;              case EDF:
<b class="nc">&nbsp;                return getBytes(254, 240);</b>
&nbsp;            }
&nbsp;          }
&nbsp;          break;
&nbsp;        case EDF:
<b class="nc">&nbsp;          assert mode == Mode.EDF; //The rightmost EDIFACT edge always contains an unlatch character</b>
&nbsp;          break;
&nbsp;      }
<b class="fc">&nbsp;      return new byte[0];</b>
&nbsp;    }
&nbsp;
&nbsp;    // Important: The function does not return the length bytes (one or two) in case of B256 encoding
&nbsp;    byte[] getDataBytes() {
<b class="fc">&nbsp;      switch (mode) {</b>
&nbsp;        case ASCII:
<b class="fc">&nbsp;          if (input.isECI(fromPosition)) {</b>
<b class="fc">&nbsp;            return getBytes(241,input.getECIValue(fromPosition) + 1);</b>
<b class="fc">&nbsp;          } else if (isExtendedASCII(input.charAt(fromPosition), input.getFNC1Character())) {</b>
<b class="fc">&nbsp;            return getBytes(235,input.charAt(fromPosition) - 127);</b>
<b class="fc">&nbsp;          } else if (characterLength == 2) {</b>
<b class="fc">&nbsp;            return getBytes((input.charAt(fromPosition) - &#39;0&#39;) * 10 + input.charAt(fromPosition + 1) - &#39;0&#39; + 130);</b>
<b class="fc">&nbsp;          } else if (input.isFNC1(fromPosition)) {</b>
<b class="nc">&nbsp;            return getBytes(232);</b>
&nbsp;          } else {
<b class="fc">&nbsp;            return getBytes(input.charAt(fromPosition) + 1);</b>
&nbsp;          }
&nbsp;        case B256:
<b class="fc">&nbsp;          return getBytes(input.charAt(fromPosition));</b>
&nbsp;        case C40:
<b class="fc">&nbsp;          return getC40Words(true, input.getFNC1Character());</b>
&nbsp;        case TEXT:
<b class="fc">&nbsp;          return getC40Words(false, input.getFNC1Character());</b>
&nbsp;        case X12:
<b class="fc">&nbsp;          return getX12Words();</b>
&nbsp;        case EDF:
<b class="fc">&nbsp;          return getEDFBytes();</b>
&nbsp;      }
<b class="nc">&nbsp;      assert false;</b>
<b class="nc">&nbsp;      return new byte[0];</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private static final class Result {
&nbsp;
&nbsp;    private final byte[] bytes;
&nbsp;
<b class="fc">&nbsp;    Result(Edge solution) {</b>
<b class="fc">&nbsp;      Input input = solution.input;</b>
<b class="fc">&nbsp;      int size = 0;</b>
<b class="fc">&nbsp;      List&lt;Byte&gt; bytesAL = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;      List&lt;Integer&gt; randomizePostfixLength = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;      List&lt;Integer&gt; randomizeLengths = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;      if ((solution.mode == Mode.C40 ||</b>
<b class="fc">&nbsp;           solution.mode == Mode.TEXT ||</b>
<b class="fc">&nbsp;           solution.mode == Mode.X12) &amp;&amp;</b>
<b class="fc">&nbsp;           solution.getEndMode() != Mode.ASCII) {</b>
<b class="fc">&nbsp;        size += prepend(MinimalEncoder.Edge.getBytes(254),bytesAL);</b>
&nbsp;      }
<b class="fc">&nbsp;      Edge current = solution;</b>
<b class="fc">&nbsp;      while (current != null) {</b>
<b class="fc">&nbsp;        size += prepend(current.getDataBytes(),bytesAL);</b>
&nbsp;
<b class="fc">&nbsp;        if (current.previous == null || current.getPreviousStartMode() != current.getMode()) {</b>
<b class="fc">&nbsp;          if (current.getMode() == Mode.B256) {</b>
<b class="fc">&nbsp;            if (size &lt;= 249) {</b>
<b class="fc">&nbsp;              bytesAL.add(0, (byte) size);</b>
<b class="fc">&nbsp;              size++;</b>
&nbsp;            } else {
<b class="fc">&nbsp;              bytesAL.add(0, (byte) (size % 250));</b>
<b class="fc">&nbsp;              bytesAL.add(0, (byte) (size / 250 + 249));</b>
<b class="fc">&nbsp;              size += 2;</b>
&nbsp;            }
<b class="fc">&nbsp;            randomizePostfixLength.add(bytesAL.size());</b>
<b class="fc">&nbsp;            randomizeLengths.add(size);</b>
&nbsp;          }
<b class="fc">&nbsp;          prepend(current.getLatchBytes(), bytesAL);</b>
<b class="fc">&nbsp;          size = 0;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        current = current.previous;</b>
&nbsp;      }
<b class="fc">&nbsp;      if (input.getMacroId() == 5) {</b>
<b class="fc">&nbsp;        size += prepend(MinimalEncoder.Edge.getBytes(236), bytesAL);</b>
<b class="fc">&nbsp;      } else if (input.getMacroId() == 6) {</b>
<b class="nc">&nbsp;        size += prepend(MinimalEncoder.Edge.getBytes(237), bytesAL);</b>
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      if (input.getFNC1Character() &gt; 0) {</b>
<b class="nc">&nbsp;        size += prepend(MinimalEncoder.Edge.getBytes(232), bytesAL);</b>
&nbsp;      }
<b class="fc">&nbsp;      for (int i = 0; i &lt; randomizePostfixLength.size(); i++) {</b>
<b class="fc">&nbsp;        applyRandomPattern(bytesAL,bytesAL.size() - randomizePostfixLength.get(i), randomizeLengths.get(i));</b>
&nbsp;      }
&nbsp;      //add padding
<b class="fc">&nbsp;      int capacity = solution.getMinSymbolSize(bytesAL.size());</b>
<b class="fc">&nbsp;      if (bytesAL.size() &lt; capacity) {</b>
<b class="fc">&nbsp;        bytesAL.add((byte) 129);</b>
&nbsp;      }
<b class="fc">&nbsp;      while (bytesAL.size() &lt; capacity) {</b>
<b class="fc">&nbsp;        bytesAL.add((byte) randomize253State(bytesAL.size() + 1));</b>
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      bytes = new byte[bytesAL.size()];</b>
<b class="fc">&nbsp;      for (int i = 0; i &lt; bytes.length; i++) {</b>
<b class="fc">&nbsp;        bytes[i] = bytesAL.get(i);</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    static int prepend(byte[] bytes, List&lt;Byte&gt; into) {
<b class="fc">&nbsp;      for (int i = bytes.length - 1; i &gt;= 0; i--) {</b>
<b class="fc">&nbsp;        into.add(0, bytes[i]);</b>
&nbsp;      }
<b class="fc">&nbsp;      return bytes.length;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static int randomize253State(int codewordPosition) {
<b class="fc">&nbsp;      int pseudoRandom = ((149 * codewordPosition) % 253) + 1;</b>
<b class="fc">&nbsp;      int tempVariable = 129 + pseudoRandom;</b>
<b class="fc">&nbsp;      return tempVariable &lt;= 254 ? tempVariable : tempVariable - 254;</b>
&nbsp;    }
&nbsp;
&nbsp;    static void applyRandomPattern(List&lt;Byte&gt; bytesAL,int startPosition, int length) {
<b class="fc">&nbsp;      for (int i = 0; i &lt; length; i++) {</b>
&nbsp;        //See &quot;B.1 253-state algorithm
<b class="fc">&nbsp;        int Pad_codeword_position = startPosition + i;</b>
<b class="fc">&nbsp;        int Pad_codeword_value = bytesAL.get(Pad_codeword_position) &amp; 0xff;</b>
<b class="fc">&nbsp;        int pseudo_random_number = ((149 * (Pad_codeword_position + 1)) % 255) + 1;</b>
<b class="fc">&nbsp;        int temp_variable = Pad_codeword_value + pseudo_random_number;</b>
<b class="fc">&nbsp;        bytesAL.set(Pad_codeword_position, (byte) (temp_variable &lt;= 255 ? temp_variable : temp_variable - 256));</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    public byte[] getBytes() {
<b class="fc">&nbsp;      return bytes;</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  private static final class Input extends MinimalECIInput {</b>
&nbsp;
&nbsp;    private final SymbolShapeHint shape;
&nbsp;    private final int macroId;
&nbsp;
&nbsp;    private Input(String stringToEncode, Charset priorityCharset, int fnc1, SymbolShapeHint shape, int macroId) {
<b class="fc">&nbsp;      super(stringToEncode, priorityCharset, fnc1);</b>
<b class="fc">&nbsp;      this.shape = shape;</b>
<b class="fc">&nbsp;      this.macroId = macroId;</b>
&nbsp;    }
&nbsp;
&nbsp;    private int getMacroId() {
<b class="fc">&nbsp;      return macroId;</b>
&nbsp;    }
&nbsp;
&nbsp;    private SymbolShapeHint getShapeHint() {
<b class="fc">&nbsp;      return shape;</b>
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-12 23:26</div>
</div>
</body>
</html>
